// Used for dev-local node environment
// This does not set runtime variables!
// But since angular builds fresh on file changes, it loads the new environment.

import * as fs from 'fs';
import * as dotenv from 'dotenv';

// Read the .env file - relative to package.json (executor)
const envConfig = dotenv.parse(fs.readFileSync('./../.env'));

// Function to determine the type of the env value
// Supports: bool, int (for ports) and string - defaults to string
const parseValue = (value) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    if (!isNaN(value) && Number.isInteger(parseFloat(value))) return parseInt(value, 10);
    return `'${value}'`;
};

// Add comments
let envFileContent = ``;
envFileContent += `// This file is generated by \`set-local-env.mjs\`!\n`;
envFileContent += `// It reads in the values from \`.env\` to not set them on the local machine.\n`;
envFileContent += `// Changes must thus be made in \`set-local-env.mjs\` and/or \`.env\` to apply here.\n`;
envFileContent += `// This is used on the node configuration \`dev-local\`.\n`;
envFileContent += `// The list of which env maps to which file can be found in \`angular.json\`.\n\n`;

// Create environment file content dynamically
envFileContent += `export const environment = {\n`;

for (const [key, value] of Object.entries(envConfig)) {
    envFileContent += `    ${key}: ${parseValue(value)},\n`;
}

envFileContent += '};\n';

// Write to the appropriate environment file - relative to package.json (executor)
fs.writeFileSync('src/environments/environment.local.ts', envFileContent);

import { Logger, createLogger, format, transports } from "winston";
import logLevel, { logLevelMapper } from "../utils/log_levels";
import { getColorizedLevel } from "../utils/colors";
import "winston-daily-rotate-file";

/**
 * Creates and returns a production logger instance using the winston library.
 * This logger is configured to output both to the console and to files.
 *
 * The console output is color-coded based on the log level and includes timestamps.
 * The file output is structured in JSON format and separated by log levels.
 *
 * In a production environment, this logger is more conservative about what it logs to
 * the console but keeps more detailed logs in files.
 *
 * @param {string} [logging_folder="./logs"] - The path to the folder where log files should be saved.
 * @returns {Logger} The configured logger instance for production environment.
 */
export default function productionLogger(
	logging_folder: string = "./logs",
): Logger {
	const verboseTransport = new transports.DailyRotateFile({
		level: "verbose",
		maxSize: "20m",
		maxFiles: "14d",
		zippedArchive: true,
		format: format.combine(
			format.timestamp({
				format: "YYYY-MM-DD HH:mm:ss",
			}),
			format.printf(
				({ level, message, timestamp, ...metadata }) =>
					JSON.stringify({
						time: timestamp,
						level: logLevelMapper(level),
						message: message,
						meta:
							metadata != null && Object.entries(metadata).length > 0
								? metadata
								: undefined,
					}) + ",",
			),
		),
		filename: logging_folder + "/verbose.log",
	});

	const infoTransport = new transports.DailyRotateFile({
		level: "warn",
		maxSize: "20m",
		maxFiles: "14d",
		zippedArchive: true,
		format: format.combine(
			format.timestamp({
				format: "YYYY-MM-DD HH:mm:ss",
			}),
			format.printf(
				({ level, message, timestamp, ...metadata }) =>
					JSON.stringify({
						time: timestamp,
						level: logLevelMapper(level),
						message: message,
						meta:
							metadata != null && Object.entries(metadata).length > 0
								? metadata
								: undefined,
					}) + ",",
			),
		),
		filename: logging_folder + "/warn.log",
	});

	const logger = createLogger({
		levels: logLevel,
		transports: [
			new transports.Console({
				level: "warn",
				format: format.combine(
					format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
					format.errors({ stack: true }),
					format.printf(({ level, message, timestamp, meta }) => {
						let rstr = `${getColorizedLevel(level)} ${timestamp} - ${message}`;

						if (meta && meta["responseTime"]) {
							rstr += " - " + meta["responseTime"] + "ms";
						}
						return rstr;
					}),
				),
			}),

			verboseTransport,

			infoTransport,
		],
	});

	verboseTransport.on("rotate", (oldFilename, newFilename) => {
		logger.info("Rotated verbose log file: " + newFilename, {
			oldFilename,
			newFilename,
		});
	});

	infoTransport.on("rotate", (oldFilename, newFilename) => {
		logger.info("Rotated info log file: " + newFilename, {
			oldFilename,
			newFilename,
		});
	});

	verboseTransport.on("error", (error) => {
		console.error("Error rotating verbose log file", { error: error });
	});

	infoTransport.on("error", (error) => {
		console.error("Error rotating info log file", { error: error });
	});

	return logger;
}

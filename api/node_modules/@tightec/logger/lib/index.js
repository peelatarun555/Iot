"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const development_1 = __importDefault(require("./logger/development"));
const production_1 = __importDefault(require("./logger/production"));
const test_1 = __importDefault(require("./logger/test"));
class Logger {
    logger;
    static _instance;
    loggingFolder = null;
    constructor() {
        this.logger = (0, development_1.default)(this.loggingFolder);
    }
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    info = (message, meta) => {
        this.logger.log("info", message, meta);
    };
    debug = (message, meta) => {
        this.logger.log("debug", message, meta);
    };
    warn = (message, meta) => {
        this.logger.log("warn", message, meta);
    };
    http = (message, meta) => {
        this.logger.log("http", message, meta);
    };
    error = (message, meta) => {
        this.logger.log("error", message.toString(), meta);
    };
    verbose = (message, meta) => {
        this.logger.log("verbose", message, meta);
    };
    configure(options) {
        if (options?.loggingFolder) {
            this.loggingFolder = options.loggingFolder;
        }
        if (options?.logger) {
            switch (options.logger) {
                case "production":
                    this.logger = (0, production_1.default)(this.loggingFolder ?? "./logs");
                    break;
                case "test":
                    this.logger = (0, test_1.default)();
                    break;
                default:
                    this.logger = (0, development_1.default)(this.loggingFolder);
                    break;
            }
        }
        if (options?.logLevel) {
            this.logger.transports[0].level = options.logLevel;
        }
    }
}
exports.default = Logger.instance;
